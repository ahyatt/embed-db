#+TITLE: embed-db: Embedding Search Library for Emacs

* Introduction
The =embed-db= package provides an interface to embedding database.  These databases enable "semantic search", which is a powerful way to search over meaning.  This kind of search needs specialized storage and retrieval.

This package doesn't provide end-user functionality on its own; it is designed to be used in other packages that need semantic search.

The package does not provide embeddings, that can be done with the [[https://github.com/ahyatt/llm][llm]] package, or any source of embeddings.
* Configuring the collection
There are two concepts that together define a collection database of embeddings: the /provider/, and the /collection/.  The provider is what kind of backend we are using, such as =sqlite-vec=, or =qdrant=.  This is a struct defined by the exact provider you want to use.

The collection is, for that provider, what exact database is getting used, with each collection having its own separate data.  Collections must be created before being used.  The collection is defined by the struct ~embed-db-collection~ which has a ~name~ (used to identify the collection), ~vector-size~, and ~payload-fields~.  The ~vector-size~ will be based on the size of the embedding vector from your provider.  1536 is what Open AI uses.  ~payload-fields~ is an alist of fields and their types that defines other data fields that are inserted and retrieved when search happens, and can be queried on as well (eventually, in a future iteration of the package).

An example, putting it all together, is:

#+begin_src emacs-lisp
(defvar my-embed-provider (make-embed-qdrant-provider :api-key my-qdrant-api-key :url my-drant-url))
(defvar my-embed-collection (make-embed-db-collection :name "my test collection" :vector-size 1536 :payload-fields (('my-id . 'string))))
#+end_src

The provider will be supplied by the end-user, specifying how they want things stored, and any data necessary for that storage and retrieval to function.  The collection is typically partially supplied by the application, with the possible exception of embedding size, which may be dependent on the exact embedding provider they are using.

Collections must be created before they can be used with ~embed-db-create~, and ~embed-db-exists~ can return whether the collection exists.
#+begin_src emacs-lisp
(unless (embed-db-exists my-embed-provider my-embed-collection)
  (embed-db-create my-embed-provider my-embed-collection))
#+end_src

They can also be deleted with ~embed-db-delete~.

* Adding and replacing data
Before data is queried, it must be added.  This is done via a batch operation on
a group of data, ~embed-db-upsert-items~.  This either creates an item in the collection
or replaces it, based on the =id= of the item.  Here's an example of adding or
replacing one item:

#+begin_src emacs-lisp
(embed-db-upsert-items my-embed-provider my-embed-collection
                 (list (make-embed-db-item
                        :id "example-id"
                        :vector [0.1 0.2 0.3 0.4]
                        :payload (:my-id "235913926"))))
#+end_src

These can be deleted with ~embed-db-delete-item~ and retrieved by ID with ~embed-db-get-item~.

IDs used in =embed-db= *must* be =uint64= values.  If you have another ID you need to use to tie it together with other storage, that should go into the =payload=.
* Querying data
Querying the database can be done with ~embed-db-search-by-vector~, passing it a vector and optionally a number of results to return (10 is the default).
#+begin_src emacs-lisp
(embed-db-search-by-vector my-embed-provider my-embed-collection [0.3 0.1 0.5 -0.9] 20)
#+end_src

This will return the specifies number of =embed-db-item= structs, with the payloads they were stored with.

